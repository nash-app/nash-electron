import { app, BrowserWindow, ipcMain, dialog, shell } from "electron";
import * as path from "path";
import { exec, spawn, type ChildProcess } from "child_process";
import * as fs from "fs";
import * as os from "os";
import * as net from "net";
import dockIcon from "../public/icon.png";
import { readConfig, writeConfig } from "./config";
import {
  NASH_MCP_DIR,
  NASH_MCP_SERVER_VERSION,
  NASH_LOCAL_SERVER_VERSION,
  TERMS_OF_SERVICE_URL,
  NASH_LOCAL_SERVER_RUN_COMMAND,
  NASH_LOCAL_SERVER_PORT,
} from "./constants";
import https from "https";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

const absoluteIconPath = path.join(__dirname, dockIcon);

// Define the Nash installation directory path
const nashInstallPath = path.join(
  os.homedir(),
  "Library",
  "Application Support",
  "Nash",
  NASH_MCP_DIR
);

// Define the secrets file path
const secretsFilePath = path.join(
  os.homedir(),
  "Library",
  "Application Support",
  "Nash",
  "secrets.json"
);

// Define the keys file path
const keysFilePath = path.join(
  os.homedir(),
  "Library",
  "Application Support",
  "Nash",
  "models.json"
);

// Define the tasks file path
const tasksFilePath = path.join(
  os.homedir(),
  "Library",
  "Application Support",
  "Nash",
  "tasks.json"
);

// Track the Local server process
let localServerProcess: ChildProcess | null = null;

// Function to read secrets from file
async function readSecrets() {
  if (!fs.existsSync(secretsFilePath)) {
    return [];
  }

  try {
    const data = await fs.promises.readFile(secretsFilePath, "utf8");
    return JSON.parse(data);
  } catch (error) {
    return [];
  }
}

// Function to write secrets to file
async function writeSecrets(secrets: any[]) {
  try {
    const nashDir = path.dirname(secretsFilePath);
    if (!fs.existsSync(nashDir)) {
      await fs.promises.mkdir(nashDir, { recursive: true });
    }
    await fs.promises.writeFile(
      secretsFilePath,
      JSON.stringify(secrets, null, 2),
      "utf8"
    );
    return true;
  } catch (error) {
    return false;
  }
}

// Function to add a new secret
async function addSecret(key: string, value: string, description: string) {
  try {
    const secrets = await readSecrets();
    const existingIndex = secrets.findIndex((s: any) => s.key === key);

    if (existingIndex >= 0) {
      secrets[existingIndex] = { key, value, description };
    } else {
      secrets.push({ key, value, description });
    }

    return await writeSecrets(secrets);
  } catch (error) {
    return false;
  }
}

// Function to delete a secret
async function deleteSecret(key: string) {
  try {
    const secrets = await readSecrets();
    const existingIndex = secrets.findIndex((s: any) => s.key === key);

    if (existingIndex === -1) {
      return false;
    }

    const filteredSecrets = secrets.filter((s: any) => s.key !== key);
    return await writeSecrets(filteredSecrets);
  } catch (error) {
    return false;
  }
}

// Function to read keys from file
async function readKeys() {
  if (!fs.existsSync(keysFilePath)) {
    return [];
  }

  try {
    const data = await fs.promises.readFile(keysFilePath, "utf8");
    return JSON.parse(data);
  } catch (error) {
    return [];
  }
}

// Function to write keys to file
async function writeKeys(keys: any[]) {
  try {
    const nashDir = path.dirname(keysFilePath);
    if (!fs.existsSync(nashDir)) {
      await fs.promises.mkdir(nashDir, { recursive: true });
    }
    await fs.promises.writeFile(
      keysFilePath,
      JSON.stringify(keys, null, 2),
      "utf8"
    );
    return true;
  } catch (error) {
    return false;
  }
}

// Function to add a new key
async function addKey(provider: string, value: string) {
  try {
    const keys = await readKeys();
    const existingIndex = keys.findIndex((k: any) => k.provider === provider);

    if (existingIndex >= 0) {
      keys[existingIndex] = { provider, value };
    } else {
      keys.push({ provider, value });
    }

    return await writeKeys(keys);
  } catch (error) {
    return false;
  }
}

// Function to delete a key
async function deleteKey(provider: string) {
  try {
    const keys = await readKeys();
    const filteredKeys = keys.filter((k: any) => k.provider !== provider);
    return await writeKeys(filteredKeys);
  } catch (error) {
    return false;
  }
}

// Function to check installed apps
function checkInstalledApps() {
  const appSupportPath = path.join(
    os.homedir(),
    "Library",
    "Application Support"
  );

  const appConfigs = [
    {
      name: "Claude",
      path: path.join(appSupportPath, "Claude"),
      configCheck: async () => {
        const config = readConfig("claude");
        return config.mcpServers?.Nash !== undefined;
      },
    },
    {
      name: "Cline",
      path: path.join(
        appSupportPath,
        "Code",
        "User",
        "globalStorage",
        "saoudrizwan.claude-dev"
      ),
      configCheck: async () => {
        const config = readConfig("cline");
        return config.mcpServers?.Nash !== undefined;
      },
    },
    {
      name: "Roo-Cline",
      path: path.join(
        appSupportPath,
        "Code",
        "User",
        "globalStorage",
        "rooveterinaryinc.roo-cline"
      ),
      configCheck: async () => {
        const config = readConfig("roo-cline");
        return config.mcpServers?.Nash !== undefined;
      },
    },
    {
      name: "Windsurf",
      path: path.join(os.homedir(), ".codeium", "windsurf"),
      configCheck: async () => {
        const config = readConfig("windsurf");
        return config.mcpServers?.Nash !== undefined;
      },
    },
    {
      name: "Witsy",
      path: path.join(appSupportPath, "Witsy"),
      configCheck: async () => {
        const config = readConfig("witsy");
        return config.mcpServers?.Nash !== undefined;
      },
    },
    {
      name: "Enconvo",
      path: path.join(os.homedir(), ".config", "enconvo"),
      configCheck: async () => {
        const config = readConfig("enconvo");
        return config.mcpServers?.Nash !== undefined;
      },
    },
    {
      name: "Cursor",
      path: path.join(os.homedir(), ".cursor"),
      configCheck: async () => {
        const config = readConfig("cursor");
        return config.mcpServers?.Nash !== undefined;
      },
    },
  ];

  return Promise.all(
    appConfigs
      .filter((config) => fs.existsSync(config.path))
      .map(async (config) => ({
        name: config.name,
        added: config.configCheck ? await config.configCheck() : false,
      }))
  );
}

// Check if Nash is installed
function checkNashInstalled() {
  try {
    return fs.existsSync(nashInstallPath);
  } catch (error) {
    return false;
  }
}

function runInstallScript() {
  // Create a temporary directory for our script
  const tempDir = path.join(os.tmpdir(), "nash-installer");
  try {
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true });
    }
  } catch (error) {
    dialog.showErrorBox(
      "Installation Error",
      "Failed to create temporary directory for installation."
    );
    return Promise.reject(error);
  }

  // Determine script path based on environment
  const scriptPath = app.isPackaged
    ? path.join(process.resourcesPath, "install.sh")
    : path.join(app.getAppPath(), "src", "install.sh");

  // Copy script to temp and make executable
  const tmpPath = path.join(tempDir, "install.sh");
  try {
    fs.copyFileSync(scriptPath, tmpPath);
    fs.chmodSync(tmpPath, "755");
  } catch (error) {
    dialog.showErrorBox(
      "Installation Error",
      "Failed to prepare installation script."
    );
    return Promise.reject(error);
  }

  return new Promise((resolve, reject) => {
    exec(
      `/bin/bash ${tmpPath} ${NASH_MCP_SERVER_VERSION} ${NASH_LOCAL_SERVER_VERSION}`,
      { cwd: os.homedir() },
      (error) => {
        // Clean up temp file
        try {
          fs.unlinkSync(tmpPath);
        } catch (cleanupError) {
          // Ignore cleanup errors
        }

        if (error) {
          dialog.showErrorBox("Installation Error", error.message);
          reject(error);
          return;
        }

        // Signal installation success to renderer
        mainWindow.webContents.send("installation-success");
        resolve(true);
      }
    );
  });
}

// Function to configure MCP server for a specific client
async function configureMcpServer(clientName: string): Promise<boolean> {
  try {
    const config = readConfig(clientName);

    // Ensure mcpServers object exists
    if (!config.mcpServers) {
      config.mcpServers = {};
    }

    // Add Nash MCP server configuration
    config.mcpServers.Nash = {
      command: path.join(nashInstallPath, ".venv/bin/mcp"),
      args: ["run", path.join(nashInstallPath, "src/nash_mcp/server.py")],
    };

    // Write updated config
    writeConfig(config, clientName);

    return true;
  } catch (error) {
    return false;
  }
}

// Function to check if Cursor is installed
function checkCursorInstalled() {
  try {
    const cursorPath = path.join(os.homedir(), ".cursor");
    return fs.existsSync(cursorPath);
  } catch (error) {
    console.error("Error checking Cursor installation:", error);
    return false;
  }
}

// Function to read tasks from file
async function readTasks() {
  if (!fs.existsSync(tasksFilePath)) {
    return null;
  }

  try {
    const data = await fs.promises.readFile(tasksFilePath, "utf8");
    return data;
  } catch (error) {
    console.error("Error reading tasks file:", error);
    return null;
  }
}

// Function to write tasks to file
async function writeTasks(tasks: any) {
  try {
    const nashDir = path.dirname(tasksFilePath);
    if (!fs.existsSync(nashDir)) {
      await fs.promises.mkdir(nashDir, { recursive: true });
    }
    await fs.promises.writeFile(
      tasksFilePath,
      JSON.stringify(tasks, null, 2),
      "utf8"
    );
    return true;
  } catch (error) {
    console.error("Error writing tasks:", error);
    return false;
  }
}

// Function to add a new task
async function addTask(taskId: string, task: any) {
  try {
    if (!task.prompt) {
      return false;
    }

    const content = await readTasks();
    const tasks = content ? JSON.parse(content) : {};

    if (tasks[taskId]) {
      return false; // Task ID already exists
    }

    tasks[taskId] = task;
    return await writeTasks(tasks);
  } catch (error) {
    console.error("Error adding task:", error);
    return false;
  }
}

// Function to delete a task
async function deleteTask(taskId: string) {
  try {
    if (!fs.existsSync(tasksFilePath)) {
      return false;
    }

    const data = await fs.promises.readFile(tasksFilePath, "utf8");
    const tasks = JSON.parse(data);

    if (!tasks[taskId]) {
      return false;
    }

    delete tasks[taskId];
    await fs.promises.writeFile(
      tasksFilePath,
      JSON.stringify(tasks, null, 2),
      "utf8"
    );
    return true;
  } catch (error) {
    console.error("Error deleting task:", error);
    return false;
  }
}

// Function to fetch terms and conditions
async function fetchTermsAndConditions(): Promise<string> {
  return new Promise((resolve, reject) => {
    https
      .get(TERMS_OF_SERVICE_URL, (res) => {
        let data = "";

        res.on("data", (chunk) => {
          data += chunk;
        });

        res.on("end", () => {
          resolve(data);
        });

        res.on("error", (error) => {
          reject(error);
        });
      })
      .on("error", (error) => {
        reject(error);
      });
  });
}

// Store mainWindow reference
let mainWindow: BrowserWindow;

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    height: 750,
    width: 900,
    minHeight: 750,
    minWidth: 900,
    titleBarStyle: "hiddenInset",
    icon: path.join(__dirname, dockIcon),
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      sandbox: false,
      nodeIntegration: false,
      webSecurity: true,
      // Add CSP headers
      additionalArguments: [`--lang=en-US`, `--accept-lang=en-US`],
    },
    show: false,
    backgroundColor: "#0f0f0f", // Dark background matching our new color
  });

  // Set CSP headers
  mainWindow.webContents.session.webRequest.onHeadersReceived(
    (details, callback) => {
      callback({
        responseHeaders: {
          ...details.responseHeaders,
          "Content-Security-Policy": [
            "default-src 'self' 'unsafe-inline' data:;" +
              "connect-src 'self' http://localhost:* ws://localhost:* data:;" +
              "script-src 'self' 'unsafe-eval' 'unsafe-inline';" +
              "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;" +
              "font-src 'self' https://fonts.gstatic.com;" +
              "img-src 'self' data: blob: file:;",
          ],
        },
      });
    }
  );

  // Handle external links
  mainWindow.webContents.setWindowOpenHandler(({ url }) => {
    shell.openExternal(url);
    return { action: "deny" };
  });

  // Show window when ready to avoid flickering
  mainWindow.once("ready-to-show", () => {
    mainWindow.show();
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
};

// Function to check if a port is in use
function checkPort(port: number): Promise<boolean> {
  return new Promise((resolve) => {
    const netServer = net.createServer();

    netServer.once("error", (err: any) => {
      if (err.code === "EADDRINUSE") {
        resolve(true); // Port is in use
      }
    });

    netServer.once("listening", () => {
      netServer.close();
      resolve(false); // Port is free
    });

    netServer.listen(port);
  });
}

// Function to get process ID using a port
function getProcessOnPort(port: number): Promise<string[]> {
  return new Promise((resolve) => {
    // Use a more thorough lsof command that shows all processes
    exec(
      `lsof -i :${port} | grep -i python | awk '{print $2}'`,
      (error, stdout) => {
        if (error || !stdout) {
          resolve([]);
          return;
        }
        // Return all PIDs found
        const pids = stdout.trim().split("\n").filter(Boolean);
        resolve(pids);
      }
    );
  });
}

// Function to kill a process
function killProcess(pid: string): Promise<boolean> {
  return new Promise((resolve) => {
    exec(`kill -9 ${pid}`, (error) => {
      resolve(!error);
    });
  });
}

// Function to ensure port is available
async function ensurePortAvailable(port: number): Promise<void> {
  console.log(`Checking if port ${port} is available...`);

  // Try multiple times to ensure port is truly available
  for (let attempt = 1; attempt <= 3; attempt++) {
    console.log(`Attempt ${attempt} to check port ${port}`);

    // Get all Python processes using this port
    const pids = await getProcessOnPort(port);

    if (pids.length > 0) {
      console.log(
        `Found ${
          pids.length
        } Python process(es) using port ${port}: ${pids.join(", ")}`
      );

      // Kill all Python processes found
      for (const pid of pids) {
        console.log(`Killing Python process ${pid}...`);
        await killProcess(pid);
      }

      // Wait longer to ensure processes are fully terminated
      await new Promise((resolve) => setTimeout(resolve, 2000));
    } else {
      console.log(`No Python processes found using port ${port}`);
    }

    // Double check port is actually free
    const isPortInUse = await checkPort(port);
    if (!isPortInUse) {
      console.log(`Port ${port} is confirmed available`);

      // Wait one more time to ensure stability
      await new Promise((resolve) => setTimeout(resolve, 1000));

      // Check one final time
      const finalCheck = await checkPort(port);
      if (!finalCheck) {
        return;
      }
    }

    console.log(`Port ${port} is still in use, will retry...`);
    await new Promise((resolve) => setTimeout(resolve, 2000));
  }

  throw new Error(`Port ${port} could not be freed after multiple attempts`);
}

// Modified startLocalServer function
async function startLocalServer() {
  if (localServerProcess) {
    console.log("Local server is already running");
    return;
  }

  // Check if we're in dev mode
  const isDevMode = process.env.NASH_DEV_MODE === "1";
  console.log(`isDevMode: ${isDevMode}`);

  try {
    // Check if port is already in use
    const isPortInUse = await checkPort(NASH_LOCAL_SERVER_PORT);

    if (isPortInUse) {
      if (isDevMode) {
        // In dev mode, just log and continue without starting server
        console.log(
          `Development mode: Port ${NASH_LOCAL_SERVER_PORT} already in use, will use existing server`
        );
        return;
      } else {
        // In production mode, ensure port is available before starting
        await ensurePortAvailable(NASH_LOCAL_SERVER_PORT);
      }
    }

    console.log("Starting local server...");

    // Resolve the actual path, replacing ~ with home directory
    const serverPath = NASH_LOCAL_SERVER_RUN_COMMAND.replace(
      "~/",
      `${os.homedir()}/`
    );

    localServerProcess = spawn("/bin/bash", ["-c", serverPath], {
      env: { ...process.env, PATH: process.env.PATH },
    });

    localServerProcess.stdout?.on("data", (data) => {
      console.log(`Local server stdout: ${data}`);
    });

    localServerProcess.stderr?.on("data", (data) => {
      console.error(`Local server stderr: ${data}`);
    });

    localServerProcess.on("error", (error) => {
      console.error("Failed to start Local server:", error);
      localServerProcess = null;
    });

    localServerProcess.on("exit", (code, signal) => {
      console.log(
        `Local server process exited with code ${code} and signal ${signal}`
      );
      localServerProcess = null;

      // Attempt to restart if the server crashes (but not in dev mode)
      if (code !== 0 && signal === null && !isDevMode) {
        console.log("Attempting to restart Local server...");
        setTimeout(startLocalServer, 5000); // Wait 5 seconds before attempting restart
      }
    });
  } catch (error) {
    console.error("Error starting Local server:", error);
    localServerProcess = null;

    // Show error dialog for port conflicts (but not in dev mode)
    if (!isDevMode && error instanceof Error) {
      dialog.showErrorBox(
        "Local Server Error",
        `Failed to start Local server: ${error.message}`
      );
    }
  }
}

// Function to stop the Local server
function stopLocalServer() {
  if (!localServerProcess) {
    console.log("Local server is not running");

    // Even if our process reference is null, double-check if anything is using our port
    getProcessOnPort(NASH_LOCAL_SERVER_PORT).then((pids) => {
      if (pids.length > 0) {
        console.log(
          `Found orphaned processes on port ${NASH_LOCAL_SERVER_PORT}: ${pids.join(
            ", "
          )}`
        );
        pids.forEach((pid) => {
          console.log(`Killing orphaned process ${pid}...`);
          killProcess(pid);
        });
      }
    });

    return;
  }

  console.log("Stopping Local server...");

  // Try graceful termination first
  try {
    localServerProcess.kill("SIGTERM");

    // Double check with process ID if available
    if (localServerProcess.pid) {
      console.log(`Sent SIGTERM to process ${localServerProcess.pid}...`);
      exec(`kill -15 ${localServerProcess.pid}`);
    }
  } catch (error) {
    console.error("Error stopping server gracefully:", error);
  }

  // After a short delay, force kill if still running
  setTimeout(() => {
    try {
      if (localServerProcess && !localServerProcess.killed) {
        console.log("Server still running, force killing...");
        localServerProcess.kill("SIGKILL");

        if (localServerProcess.pid) {
          exec(`kill -9 ${localServerProcess.pid}`);
        }
      }

      // Also check for any processes still using our port
      getProcessOnPort(NASH_LOCAL_SERVER_PORT).then((pids) => {
        if (pids.length > 0) {
          console.log(
            `Found processes still using port ${NASH_LOCAL_SERVER_PORT}: ${pids.join(
              ", "
            )}`
          );
          pids.forEach((pid) => {
            console.log(`Force killing process ${pid}...`);
            killProcess(pid);
          });
        }
      });
    } catch (error) {
      console.error("Error force killing server:", error);
    } finally {
      localServerProcess = null;
    }
  }, 500);

  // Clear the reference
  localServerProcess = null;
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.whenReady().then(() => {
  if (process.platform === "darwin") {
    app.dock.setIcon(absoluteIconPath);
  }

  // Check if we're in dev mode
  const isDevMode = process.env.NASH_DEV_MODE === "1";

  // Only start the Local server when not in dev mode
  if (!isDevMode) {
    startLocalServer();
  } else {
    console.log(
      "Development mode: Not starting local server, using externally managed server"
    );
  }

  // Register all IPC handlers first
  ipcMain.handle("run-install", (event) => {
    return runInstallScript();
  });

  ipcMain.handle("check-nash-installed", (event) => {
    return checkNashInstalled();
  });

  ipcMain.handle("check-installed-apps", (event) => {
    return checkInstalledApps();
  });

  ipcMain.handle("check-cursor-installed", (event) => {
    return checkCursorInstalled();
  });

  // Add terms and conditions handler
  ipcMain.handle("fetch-terms", async () => {
    try {
      const terms = await fetchTermsAndConditions();
      return terms;
    } catch (error) {
      console.error("Error fetching terms:", error);
      throw error;
    }
  });

  // Register secrets management handlers
  ipcMain.handle("get-secrets", async () => {
    return await readSecrets();
  });

  ipcMain.handle("add-secret", async (_, key, value, description) => {
    return await addSecret(key, value, description);
  });

  ipcMain.handle("delete-secret", async (_, key) => {
    return await deleteSecret(key);
  });

  // Register tasks management handlers
  ipcMain.handle("get-tasks", async () => {
    return await readTasks();
  });

  ipcMain.handle("add-task", async (_, taskId: string, task: any) => {
    return await addTask(taskId, task);
  });

  ipcMain.handle("delete-task", async (_, taskId: string) => {
    return await deleteTask(taskId);
  });

  // Register keys management handlers
  ipcMain.handle("getKeys", async () => {
    return await readKeys();
  });

  ipcMain.handle("addKey", async (_, provider, value) => {
    return await addKey(provider, value);
  });

  ipcMain.handle("deleteKey", async (_, provider) => {
    return await deleteKey(provider);
  });

  // Register model config handlers
  ipcMain.handle("getModelConfigs", async () => {
    return await readModelConfigs();
  });

  ipcMain.handle(
    "saveModelConfig",
    async (
      _,
      provider: string,
      config: {
        baseUrl?: string;
        selectedModel?: string;
        headers?: Record<string, string>;
      }
    ) => {
      return await saveModelConfig(provider, config);
    }
  );

  ipcMain.handle(
    "deleteModelConfig",
    async (_, provider: string, configKey: string) => {
      return await deleteModelConfig(provider, configKey);
    }
  );

  ipcMain.handle("configure-mcp", async (_, appName) => {
    const normalizedAppName =
      appName.toLowerCase() as keyof typeof appToConfigMap;
    // Map app names to their config names
    const appToConfigMap = {
      claude: "claude",
      cline: "cline",
      "roo-cline": "roo-cline",
      windsurf: "windsurf",
      witsy: "witsy",
      enconvo: "enconvo",
      cursor: "cursor",
    };
    const configName = appToConfigMap[normalizedAppName];
    if (!configName) {
      console.error(`Unknown app name: ${appName}`);
      return false;
    }
    return await configureMcpServer(configName);
  });

  // Then create the window
  createWindow();

  app.on("activate", () => {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
});

// Add cleanup when app is quitting
app.on("before-quit", () => {
  stopLocalServer();
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  // Always stop the server when all windows are closed
  stopLocalServer();

  if (process.platform !== "darwin") {
    app.quit();
  }
});

async function readModelConfigs() {
  try {
    if (!fs.existsSync(keysFilePath)) {
      return [];
    }
    const data = await fs.promises.readFile(keysFilePath, "utf8");
    return JSON.parse(data);
  } catch (error) {
    console.error("Error reading model configs:", error);
    return [];
  }
}

async function writeModelConfigs(configs: any[]) {
  try {
    await fs.promises.writeFile(keysFilePath, JSON.stringify(configs, null, 2));
    return true;
  } catch (error) {
    console.error("Error writing model configs:", error);
    return false;
  }
}

async function saveModelConfig(
  provider: string,
  config: {
    baseUrl?: string;
    selectedModel?: string;
    headers?: Record<string, string>;
  }
) {
  try {
    const configs = await readModelConfigs();
    const existingIndex = configs.findIndex(
      (c: any) => c.provider === provider
    );

    if (existingIndex !== -1) {
      configs[existingIndex] = { ...configs[existingIndex], ...config };
    } else {
      configs.push({ provider, ...config });
    }

    return await writeModelConfigs(configs);
  } catch (error) {
    console.error("Error saving model config:", error);
    return false;
  }
}

async function deleteModelConfig(provider: string, configKey: string) {
  try {
    const configs = await readModelConfigs();
    const existingIndex = configs.findIndex(
      (c: any) => c.provider === provider
    );

    if (existingIndex !== -1) {
      // If the config exists, remove the specified key
      const config = configs[existingIndex];
      delete config[configKey];

      // If the config is now empty (no keys left), remove it entirely
      if (Object.keys(config).length <= 1) {
        // <= 1 because 'provider' key will always exist
        configs.splice(existingIndex, 1);
      }
    }

    return await writeModelConfigs(configs);
  } catch (error) {
    console.error("Error deleting model config:", error);
    return false;
  }
}
